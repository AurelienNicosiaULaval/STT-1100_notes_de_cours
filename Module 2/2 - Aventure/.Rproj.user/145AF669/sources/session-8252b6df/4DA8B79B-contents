---
title: "Aventure 4 - Nettoyer pour mieux assurer"
subtitle: "STT-1100 Introduction Ã  la science des donnÃ©es"
author: 
  - institute: "UniversitÃ© Laval"
format: 
  html:
    toc: true
    toc-title: "Plan de lâ€™aventure"
    embed-resources: true
    link-external-newwindow: true
    code-link: true
    theme: flatly
    css: [../../css/base_css.css]
editor: visual
editor_options: 
  chunk_output_type: console
---

# ğŸ§  Mise en situation

Vous venez tout juste de commencer un stage comme **ingÃ©nieurÂ·e de donnÃ©es junior** dans une grande **compagnie dâ€™assurance**. Vous travaillez avec Alex, unÂ·e analyste dâ€™affaires expÃ©rimentÃ©Â·e, qui vous a confiÃ© une mission importante.

Alex vous a fourni une base de donnÃ©es extraite dâ€™un ancien systÃ¨me dâ€™archives. Cette base contient des informations clÃ©s sur les clients, les polices dâ€™assurance et les rÃ©clamations. Malheureusement, la base est **truffÃ©e dâ€™erreurs** : doublons, valeurs manquantes, incohÃ©rences, erreurs de format, fautes de frappeâ€¦

Votre rÃ´le sera dâ€™assurer la **qualitÃ© des donnÃ©es** pour permettre Ã  Alex de faire une analyse fiable.

# ğŸ¯ Objectifs de lâ€™aventure

-   Importer une base de donnÃ©es brute (`Dataset_pratique.csv`).
-   Identifier diffÃ©rents types dâ€™erreurs courantes.
-   Nettoyer et transformer les donnÃ©es avec `dplyr`, `forcats` et `stringr`.
-   Documenter de faÃ§on claire **toutes les modifications apportÃ©es** Ã  la base.

# âœ… Comment rÃ©ussir cette aventure ?

Ã€ la fin de cette aventure, vous devrez :

1.  Fournir une **base de donnÃ©es propre** (`donnees_propres.csv`).
2.  Maintenir une **liste R structurÃ©e** appelÃ©e `journal_nettoyage` dans votre script.

> ğŸ’¡ Pensez Ã  **documenter chaque Ã©tape de votre nettoyage**. Votre rigueur est votre meilleure alliÃ©e !

# ğŸ—ƒï¸ Typologie des erreurs et structure de la liste

Voici un tableau de rÃ©fÃ©rence pour les types dâ€™erreurs que vous pouvez rencontrer :

| Code | Type dâ€™erreur | Description | Exemple |
|------------------|------------------|------------------|------------------|
| VM | Valeurs manquantes | Champs essentiels non remplis | Lignes sans valeur pour `age` ou `revenu_annuel` |
| DF | Doublons | Lignes identiques ou trÃ¨s similaires | Deux lignes avec le mÃªme `id_client` |
| IF | IncohÃ©rences de format | DonnÃ©es du mÃªme type mais formats diffÃ©rents | `date_naissance` en formats mixtes (`1980-01-01`, `01/01/1980`) |
| VA | Valeurs aberrantes | Valeurs manifestement extrÃªmes ou irrÃ©alistes | `revenu_annuel = 99,999,999 $` |
| FT | Fautes de frappe | Erreurs typographiques affectant la cohÃ©rence | Province inscrite comme "QuebÃ©c", "quebec", "QuÃ©bec" |
| RC | Recodage ou regroupement | CatÃ©gories similaires Ã  fusionner | "sans emploi", "inactif", "au chÃ´mage" |
| TY | Types mal dÃ©finis | Mauvais type de variable pour les donnÃ©es | `revenu_annuel` enregistrÃ© comme texte |
| LG | Erreurs logiques | Relations temporelles ou conditionnelles incorrectes | Client nÃ© en 2022 mais contrat signÃ© en 2020 |
| CI | IncohÃ©rences inter-variables | DonnÃ©es incohÃ©rentes entre deux colonnes | `province = "QuÃ©bec"` mais `code_postal` commence par "H" |
| RU | DonnÃ©es redondantes ou inutiles | Colonnes dupliquÃ©es ou peu pertinentes | Deux colonnes contenant la mÃªme information |
| TR | Troncations ou mauvaise fusion | ChaÃ®nes de texte tronquÃ©es ou mal fusionnÃ©es | Noms de famille coupÃ©s comme "Du" |
| EC | ProblÃ¨mes d'encodage | CaractÃ¨res spÃ©ciaux mal encodÃ©s | "ÃƒÂ©" au lieu de "Ã©" |

Cette typologie permet de structurer rigoureusement la dÃ©tection et la documentation des erreurs dans le journal de nettoyage R (liste `journal_nettoyage`).

Dans votre script, vous allez construire la liste `journal_nettoyage` structurÃ©e par catÃ©gorie :

```{r}
journal_nettoyage <- list(
  VM = list(
    list(
      id = c(12, 27),
      variables = "age",
      probleme = "Valeurs manquantes",
      action = "RemplacÃ© par la mÃ©diane",
      justification = "Pour garder la cohÃ©rence"
    )
  ),
  DF = list(
    list(
      id = c(45, 46),
      variables = "id_client",
      probleme = "Doublons complets",
      action = "Suppression",
      justification = "Inutiles pour lâ€™analyse"
    )
  )
)
journal_nettoyage
```

Chaque catÃ©gorie (`VM`, `DF`, etc.) contient une **liste de corrections**, oÃ¹ chaque correction est un `list()` avec :

-   `id` : ligne(s) ou position(s) affectÃ©e(s)

-   `variables` : les variables concernÃ©es

-   `probleme` : nature du problÃ¨me

-   `action` : action effectuÃ©e

-   `justification` : pourquoi cette action a Ã©tÃ© choisie

> ğŸ” Cette structure vous aidera Ã  **rendre compte de vos modifications** de faÃ§on propre et professionnelle.

# ğŸ§ª GitHub et rendu

Comme pour les aventures prÃ©cÃ©dentes :

-   **Clonez** le dÃ©pÃ´t GitHub du module 4 depuis lâ€™organisation du cours. Vous pouvez utiliser la cheat sheet du cours si vous avez un trou de mÃ©moire.
-   Travaillez dans RStudio et **faites des commits rÃ©guliÃ¨rement** pour documenter votre avancement.
-   Votre dÃ©pÃ´t doit contenir :
    -   le script `.qmd` de votre aventure, c'est Ã  dire un document ou vous faites vos tests et construisez votre liste `journal_nettoyage` ;
    -   la liste `journal_nettoyage` dans un objet `.Rdata` ;
    -   la base de donnÃ©es nettoyÃ©e au format `.csv`.

Bonne chance, et que vos donnÃ©es soient propres ! ğŸ§½ğŸ“Š

# ğŸ“¥ Importation des donnÃ©es

Avant de nettoyer une base de donnÃ©es, il faut savoir lâ€™importer correctement. Pour cette mission, Alex vous a transmis le fichier `Dataset_pratique.csv`. Il vous recommande de :

-   charger les donnÃ©es dans R avec la fonction `read_csv()` du package `readr`,
-   examiner les premiÃ¨res lignes pour repÃ©rer les incohÃ©rences Ã©videntes,
-   et convertir immÃ©diatement les noms de colonnes en minuscules avec `janitor::clean_names()` pour faciliter les manipulations Ã  venir.

``` r
library(readr)
library(janitor)

# Importation des donnÃ©es
base <- read_csv("Dataset_pratique.csv")

# Nettoyage des noms de colonnes
base <- base %>% clean_names()

# AperÃ§u des donnÃ©es
head(base)
glimpse(base)
```

> ğŸ’¬ **Alex** : Â« Cette base est un vrai casse-tÃªte ! Jâ€™ai besoin que tu la rendes exploitable rapidement. Tu devrais commencer par repÃ©rer ce qui cloche dans les noms, les formats ou les valeurs. Â»

------------------------------------------------------------------------

# ğŸ” Exploration initiale des problÃ¨mes potentiels

## Format des variables

Maintenant que vous avez importÃ© la base, il est temps de faire une premiÃ¨re exploration pour identifier les erreurs potentielles. Voici quelques Ã©tapes clÃ©s Ã  suivre :

``` r
# Dimensions de la base
nrow(base)
ncol(base)

# Variables disponibles
names(base)

# type des variables
glimpse(base)
```

> ğŸ’¬ **Alex** : Â« Tu verras, certains types des variables ne font aucun sens... Garde une trace de tout ce que tu trouves bizarre pour quâ€™on dÃ©cide ensemble quoi en faire. Â»

Lâ€™une des fonctions les plus utiles ici est `glimpse()` (du package `dplyr`). Elle affiche un aperÃ§u des premiÃ¨res valeurs de chaque variable **ainsi que leur type** : par exemple `chr` pour une chaÃ®ne de caractÃ¨res (character), `dbl` pour un nombre dÃ©cimal (double), `int` pour un entier, ou encore `lgl` pour un boolÃ©en.

Voici un rappel des principaux types de donnÃ©es en R :

-   `character` (`chr`) : texte

-   `numeric` / `double` (`dbl`) : nombres rÃ©els

-   `integer` (`int`) : nombres entiers

-   `logical` (`lgl`) : boolÃ©ens (`TRUE`, `FALSE`)

-   `factor` : variable catÃ©gorielle Ã  niveaux dÃ©finis

-   `Date` : date au format standard R

Pour transformer une variable, vous pouvez utiliser les fonctions suivantes :

```         
as.character(base$colonne)
as.numeric(base$colonne)
as.integer(base$colonne)
as.logical(base$colonne)
as.factor(base$colonne)
```

Pensez Ã  toujours vÃ©rifier le rÃ©sultat de la transformation avec `glimpse()` ou `summary()`.

> ğŸ’¬ Alex : Â« Quand on regarde les types de variables avec glimpse(), il faut garder en tÃªte quâ€™il y a des standards en science des donnÃ©es. En gÃ©nÃ©ral, les variables contenant du texte devraient Ãªtre de type `character` ou `factor` si elles prennent un nombre limitÃ© de valeurs (par exemple, une colonne sexe ou province). Les variables contenant des nombres devraient normalement Ãªtre de type `dbl` (pour les dÃ©cimaux) ou `int` (pour les entiers), selon le cas.

> Un piÃ¨ge courant, câ€™est les identifiants ! MÃªme sâ€™ils ont lâ€™air dâ€™Ãªtre des nombres, comme une colonne `ID_client` ou `numero_contrat`, ce ne sont pas des quantitÃ©s sur lesquelles on va faire des calculs. Ce sont des Ã©tiquettes uniques. On devrait donc les convertir en character. Ã‡a Ã©vite quâ€™un identifiant comme 0012 soit transformÃ© en 12 par erreur, ou que R pense quâ€™on veut faire une moyenne avec Ã§aâ€¦ ğŸ˜…

> Bref, vÃ©rifiez bien chaque type. Posez-vous la question : est-ce que cette variable est du texte ? Est-ce que je vais calculer dessus ? Est-ce que ce sont des catÃ©gories ? Â»

## ğŸ” VÃ©rification des doublons

Un des premiers rÃ©flexes Ã  avoir dans toute opÃ©ration de nettoyage : **vÃ©rifier les doublons**. Il peut sâ€™agir :

-   de doublons **complets** (lignes identiques sur toutes les colonnes),
-   de doublons **partiels** (mÃªme identifiant, mais des valeurs lÃ©gÃ¨rement diffÃ©rentes ailleurs).

ğŸ’¡ Commencez par dÃ©tecter les doublons complets avec :

``` r
duplicated(base) %>% sum()
```

Et pour les identifier :

``` r
base[duplicated(base), ]
```

Vous pouvez ensuite les retirer :

``` r
base <- base %>% distinct()
```

Si vous voulez repÃ©rer les doublons sur une ou plusieurs colonnes clÃ©s (ex. : `ID_Variable`), utilisez :

``` r
base %>% 
  group_by(ID_Variable) %>% 
  filter(n() > 1)
```

> ğŸ’¬ **Alex** : Â« Deux clients avec le mÃªme numÃ©ro, câ€™est louche. Regarde ce qui se passe. Supprimer aveuglÃ©ment nâ€™est pas toujours la bonne solution. Note bien ce que tu fais dans le `journal_nettoyage`â€¯! Â»

Et bien sÃ»r, si vous intervenez, nâ€™oubliez pas de lâ€™indiquer dans la section `DF` de votre `journal_nettoyage`.

``` r
journal_nettoyage$DF <- append(journal_nettoyage$DF, list(
  list(
    id = c(101, 102),
    variables = "Toutes les colonnes",
    probleme = "Doublons complets",
    action = "Lignes supprimÃ©es",
    justification = "Doublons exacts dÃ©tectÃ©s automatiquement"
  )
))
```

# ğŸ§¹ Nettoyage des facteurs avec `forcats`

On continue l'exploration avec un type de variable souvent nÃ©gligÃ©â€¦ mais qui peut faire dÃ©railler toute une analyse : les **facteurs**.

En R, les facteurs sont utilisÃ©s pour reprÃ©senter des **catÃ©gories**. Par exemple, dans la colonne `VEHICLE_TYPE`, chaque valeur correspond Ã  un type de vÃ©hicule : `"car"`, `"truck"`, `"CAR"`, `"ANIMAL"`, etc.

Pour voir l'ensemble des niveaux d'un facteur, vous pouvez utiliser la fonction `levels()` :

```{r, eval=FALSE}
levels(base$VEHICLE_TYPE)
```

Bien sur, il faut que ta variable soit de type `factor` pour que cette fonction fonctionne. Si ce n'est pas le cas, vous pouvez la convertir avec `as.factor()` (voir section prÃ©cÃ©dente).

Le problÃ¨me ?\
Quand on regarde les niveaux dâ€™un facteur, on remarque souvent des **doublons dÃ©guisÃ©s** (`"car"` vs `"CAR"`), des **niveaux aberrants** (`"ANIMAL"`) ou des **catÃ©gories trÃ¨s rares** qui ne mÃ©ritent peut-Ãªtre pas leur propre niveau.

## ğŸ›  Quelques outils utiles (avec `forcats`)

Pour nettoyer tout Ã§a, voici quelques fonctions clÃ©s du package `forcats` :

-   `fct_count()` : pour compter les niveaux et repÃ©rer les anomalies
-   `fct_recode()` : pour renommer des niveaux (par exemple fusionner `"CAR"` et `"car"`)
-   `fct_collapse()` : pour fusionner plusieurs niveaux en un seul
-   `fct_lump()` : pour regrouper les niveaux rares en "Autre"
-   `fct_relevel()` ou `fct_infreq()` : pour rÃ©ordonner les niveaux

## ğŸ‘€ Ã‰tapes proposÃ©es

Prenez le temps de :

1.  **Lister les variables de type facteur** avec `glimpse()` ou `select(where(is.factor))`.
2.  **Explorer les niveaux** avec `fct_count()`.
3.  **Identifier les incohÃ©rences**, comme :
    -   mÃªmes valeurs avec casse diffÃ©rente (`"CAR"` vs `"car"`)
    -   fautes de frappe (`"Commute"` vs `"Com.mute"`)
    -   niveaux aberrants (`"ANIMAL"` dans `VEHICLE_TYPE`)

> ğŸ’¬ **Alex** : Â« Faites attention Ã  ces valeurs Ã©tranges. Si une valeur nâ€™a aucun sens dans le contexte (par exemple `"ANIMAL"` dans une colonne sur les types de vÃ©hicules), ne cherchez pas Ã  deviner. Mettez-la Ã  `NA`. On prÃ©fÃ¨re une donnÃ©e manquante quâ€™une mauvaise information. Â»

## âœï¸ Exemple Ã  adapter

``` r
# Harmoniser les minuscules/majuscules
base$VEHICLE_TYPE <- base$VEHICLE_TYPE %>% 
  str_to_title() %>%                     # "car" -> "Car", "TRUCK" -> "Truck"
  as_factor()

# Remplacer les valeurs aberrantes par NA
base$VEHICLE_TYPE <- fct_na_value_to_level(base$VEHICLE_TYPE, "ANIMAL", NA)

# Ou en changeant les niveaux directement :
base$VEHICLE_USE <- fct_collapse(
  base$VEHICLE_USE,
  Pleasure = c( "Pleasure", "Pleasure"),
  Commute = c("Commute", "Com.mute"))
```

Il ne faudra pas oublier de documenter ces modifications dans votre liste `journal_nettoyage` ! Par exemple, pour la variable `VEHICULE_USE` ci-dessus, vous pourriez ajouter :

```{r}
journal_nettoyage$RC <- append(journal_nettoyage$RC, list(
  list(
    id = c(101, 203, 317),  # Adapter avec les bonnes lignes concernÃ©es
    variables = "VEHICLE_USE",
    probleme = "Fusion de niveaux similaires (majuscules/fautes)",
    action = "Regroupement de 'Pleasure' et 'pleasure', 'Commute' et 'Com.mute'",
    justification = "AmÃ©lioration de la cohÃ©rence et rÃ©duction des doublons"
  )
))
```

âš ï¸ *Ce ne sont que des exemples. Ã€ vous d'explorer la base de donnÃ©es et de choisir ce qui est cohÃ©rent.*

# ğŸ§¼ Recette de nettoyage â€” Approfondissement

Bravoâ€¯! Vous avez dÃ©jÃ  corrigÃ© les types de variables et nettoyÃ© les facteurs les plus visibles. Maintenant, on pousse le nettoyage plus loin, en croisant **statistiques**, **relations logiques** et **comportements aberrants**. Voici votre **recette de nettoyage avancÃ©**.

## ğŸ“Š Ã‰tape 1 â€“ Statistiques descriptives sur les variables numÃ©riques

Tout comme on a vÃ©rifiÃ© les niveaux des facteurs, on doit vÃ©rifier si certaines **valeurs numÃ©riques sont aberrantes**.

Prenez chaque variable numÃ©rique et rÃ©sumez-la avec `summary()` ou un boxplot pour identifier les extrÃªmes.

ğŸ’¡ **Exemple : `COMMUTE_DISTANCE`**

``` r
summary(base$COMMUTE_DISTANCE)
ggplot(base, aes(x = COMMUTE_DISTANCE)) +
  geom_histogram(bins = 50, fill = "blue", alpha = 0.7) +
  labs(title = "Distribution de la distance de trajet domicile-travail",
       x = "Distance (km)", y = "FrÃ©quence")
```

Posez-vous la question : - Une distance de 3000 km pour se rendre au travail, câ€™est plausible ? - Est-ce que certaines valeurs sont manquantes ou nÃ©gatives ?

Si vous intervenez, n'oubliez pas de **justifier dans `journal_nettoyage`**, en utilisant le code `VA` (valeurs aberrantes) ou `VM` (valeurs manquantes).

## ğŸ“‰ Ã‰tape 2 â€“ Combinaisons incohÃ©rentes de deux facteurs

Il peut exister des **relations logiques** entre deux variables catÃ©goriques. Par exemple, le trimestre (`QUARTER`) et la saison (`SEASON`) devraient Ãªtre cohÃ©rents.

ğŸ’¡ **Exemple : `QUARTER` et `SEASON`**

``` r
table(base$QUARTER, base$SEASON)
```

> ğŸ’¬ **Alex** : Â« Si tu vois `QUARTER = 1` avec `SEASON = "Summer"`, tu devrais tiquer... Ce genre dâ€™incohÃ©rence mÃ©rite dâ€™Ãªtre notÃ©, mÃªme si tu ne sais pas quoi corriger. Â»

Vous pouvez aussi visualiser avec un graphique Ã  barres croisÃ© :

``` r
ggplot(base, aes(x = QUARTER, fill = SEASON)) +
  geom_bar(position = "fill")
```

Si vous corrigez, utilisez le code `CI` (incohÃ©rences inter-variables).

## ğŸ‘¶ Ã‰tape 3 â€“ Statistiques groupÃ©es : facteur + numÃ©rique

Autre vÃ©rification : est-ce que certaines **valeurs numÃ©riques sont incohÃ©rentes pour certains groupes** ?

ğŸ’¡ **Exemple : `AGE` selon `GENERATION`**

``` r
base %>% 
  group_by(GENERATION) %>% 
  summarise(min = min(AGE, na.rm = TRUE),
            max = max(AGE, na.rm = TRUE),
            mean = mean(AGE, na.rm = TRUE))

ggplot(base, aes(x = AGE, fill = GENERATION)) +
  geom_histogram(position = "identity", alpha = 0.6, bins = 40)
```

-   Est-ce quâ€™un bÃ©bÃ© appartient Ã  la gÃ©nÃ©ration X ?
-   Une personne de 122 ans est-elle bien classÃ©e ?

Sâ€™il y a recodage ou regroupement Ã  faire, utilisez le code `RC`.

## ğŸ§  Ã‰tape 4 â€“ Liens logiques entre deux variables numÃ©riques

Ici, on vÃ©rifie que les relations numÃ©riques **ont du sens**.

ğŸ’¡ **Exemple : `AGE` vs `YEARS_LICENSED`**

``` r
ggplot(base, aes(x = AGE, y = YEARS_LICENSED)) +
  geom_point(alpha = 0.3) 
```

-   Est-ce quâ€™il y a des points au-dessus d'une certaines lignes ? De quelle ligne parle t-on ici?
-   Peut-on avoir plus dâ€™annÃ©es de permis que dâ€™Ã¢ge ?

> ğŸ’¬ **Alex** : Â« Tu nâ€™es pas obligÃ© de corriger ici. Par contre, **si tu remarques quelque chose dâ€™Ã©trange**, prends deux minutes pour lâ€™Ã©crire dans le `journal_nettoyage`. Juste pour montrer que tu lâ€™as vu, rÃ©flÃ©chi, et que tu as pris une dÃ©cision. Câ€™est Ã§a Ãªtre rigoureux. Â»

Utilisez ici le code `LG` pour une **erreur logique**.

## ğŸ§ª Ã‰tape 5 â€“ VÃ©rifications avancÃ©es (facultatives mais pros !)

Voici quelques autres choses Ã  garder Ã  lâ€™Å“il :

-   **Variables redondantes** : deux colonnes qui disent la mÃªme chose (`CITY_NAME` et `MUNICIPALITY`)
-   **Colonnes inutiles** : identifiants internes, colonnes vides ou avec une seule modalitÃ© (`EC` ou `RU`)
-   **ProblÃ¨mes de format de texte** : accents, caractÃ¨res spÃ©ciaux (`stringr::str_detect`)
-   **Colonnes fusionnÃ©es Ã  la hÃ¢te** : chaÃ®nes comme `"Smith, John"` dans une seule cellule au lieu de deux (`TR`)
-   **Format de dates mÃ©langÃ©s** : on a laissÃ© cela de cÃ´tÃ© depuis le dÃ©but de ce cours, mais sachez que ca s'en vient, nous aurons un module spÃ©cial sur les dates.

ğŸ§¾ *Tout au long de votre nettoyage, documentez vos dÃ©cisions dans la liste `journal_nettoyage`. Le but nâ€™est pas de tout corriger, mais de montrer que vous avez su repÃ©rer les problÃ¨mes, rÃ©flÃ©chir, et intervenir quand nÃ©cessaire.*

# ğŸ‰ Mission accomplie !

Bravo dâ€™Ãªtre allÃ©Â·e jusquâ€™au bout de cette aventure ! ğŸ§½\
Vous avez maintenant acquis une solide mÃ©thodologie pour nettoyer des donnÃ©es de maniÃ¨re rigoureuse et professionnelle. Vous avez :

-   identifiÃ© et corrigÃ© des erreurs de format, de type et de cohÃ©rence ;
-   utilisÃ© les outils de `dplyr`, `stringr`, `forcats` et `ggplot2` pour explorer les donnÃ©es sous toutes leurs coutures ;
-   documentÃ© chaque intervention dans une structure claire et transparente avec la liste `journal_nettoyage`.

ğŸ’¾ **Avant de terminer**, nâ€™oubliez pas de **pousser sur GitHub** les trois Ã©lÃ©ments suivants :

1.  ğŸ“„ Le script `.qmd` de votre aventure (lÃ  oÃ¹ vous avez effectuÃ© vos tests, analyses et nettoyage)\
2.  ğŸ“¦ La liste `journal_nettoyage` enregistrÃ©e dans un objet `.Rdata`\
3.  ğŸ“Š La base de donnÃ©es nettoyÃ©e au format `.csv`

Pour sauvegarder votre liste dans un fichier `.Rdata`, utilisez simplement ce code Ã  la fin de votre script :

``` r
save(journal_nettoyage, file = "journal_nettoyage.Rdata")
```

> ğŸ’¬ **Alex** : Â« Vous venez de faire ce que peu de gens font bien : nettoyer des donnÃ©es proprement, en gardant une trace de vos dÃ©cisions. Câ€™est ce qui distingue unÂ·e vraiÂ·e professionnelÂ·le de quelquâ€™un qui bidouille. Chapeau ! Â»
